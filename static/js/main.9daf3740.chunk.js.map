{"version":3,"sources":["RoomContext.tsx","components/Background.tsx","utils.ts","components/Floor.tsx","components/Point.tsx","components/Segment.tsx","components/Size.tsx","components/Door.tsx","components/Room.tsx","components/Plan.tsx","components/UI/QuickMenu.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["RoomContext","createContext","Background","width","height","useContext","__selectedRoom","__rooms","rooms","setRooms","setSelectedRoom","addRoom","e","id","window","prompt","find","room","alert","x","clientX","y","clientY","points","getPoints","this","reduce","acc","curr","i","absX","absY","offsetX","offsetY","doors","style","tabIndex","fill","onDoubleClick","onClick","onKeyDown","keyCode","getPath","current","push","length","getAllPoints","roomPoints","Floor","polygon","stroke","Point","point","visible","roomIndex","findIndex","handle","onDrag","dnd","deltaX","deltaY","onStop","allPoints","console","log","map","otherPoint","Math","abs","className","cx","cy","r","strokeWidth","textAnchor","alignmentBaseline","pointerEvents","Segment","pathPoints","segmentIndex","__quickMenuPosition","__quickMenuState","__selectedPathPoints","__pointer","__pathNode","setQuickMenuPosition","setQuickMenuState","setSelectedPathPoints","setPointer","setPathNode","useState","isDragging","setIsDragging","a","b","data","path","line","d","segmentClicked","preventDefault","type","touches","pageX","pageY","prev","target","forEach","pathPoint","visibility","opacity","Size","dx","dy","c","round","floor","sqrt","startOffset","xlinkHref","Door","door","pointsIds","XFromOrigin","roomId","split","aIndex","bIndex","Room","isSelected","cancel","disabled","newRooms","transform","filter","el","outline","join","index","key","Plan","__doors","selectedRoom","innerWidth","innerHeight","sort","QuickMenu","quickMenuPosition","quickMenuState","selectedPathPoints","pointer","handleClose","Menu","transitionDuration","enter","exit","anchorReference","anchorPosition","top","left","undefined","open","onClose","MenuItem","persist","newPoint","clickCoords","m","p","isFinite","getPointCoords","point1","point2","splice","App","CTX","overscrollBehavior","onContextMenu","Provider","value","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9daf3740.chunk.js","sourcesContent":["import { createContext, useState } from 'react'\n\nexport const RoomContext = createContext(null) \n","import React, { useContext } from \"react\";\nimport { RoomContext } from './../RoomContext'\n\nexport default function Background({\n    width,\n    height,\n}: {\n    width: number;\n    height: number;\n}) {\n\n    const { __selectedRoom, __rooms } = useContext(RoomContext)\n\n    const [rooms, setRooms] = __rooms\n    const [_, setSelectedRoom] = __selectedRoom\n\n    const addRoom = (e: any) => {\n        const id = window.prompt(\"Dénomination de la pièce\");\n\n        if (id === '' || id === null) return\n\n        if (rooms.find((room) => room.id === id)) {\n            alert(`Une pièce nommée ${id} existe déjà. Création annulée !!!`);\n            return;\n        }\n\n        const room = {\n            id: id,\n            x : e.clientX ? e.clientX - 75 : width/2,\n            y : e.clientY ? e.clientY - 75 : height/2,\n            points: [\n                {x : 0, y : 0},\n                {x : 0, y : 150},\n                {x : 150, y : 150},\n                {x : 150, y : 0},\n            ],\n            getPoints() {\n                return this.points.reduce((acc, curr, i) => {\n                    acc[i] = {\n                        x : curr.x,\n                        y : curr.y,\n                        absX : curr.x + this.x,\n                        absY : curr.y + this.y,\n                        offsetX : this.x,\n                        offsetY : this.y,\n                        i,\n                        room : id,\n                        id : `${this.id}.${i}`\n                    }\n                    return acc\n                }, [])\n            },\n            doors : []\n        };\n\n        setRooms([...rooms, room]);\n        setSelectedRoom(room.id);\n    }\n\n    const keyHandler = e => {\n        if (e.keyCode === 78) {\n            addRoom(e)\n        }\n    }\n\n    return (\n        <rect\n            style={{'outline':'none'}}\n            tabIndex={-1}\n            id=\"background\"\n            width={width}\n            height={height}\n            fill=\"#38a0f9\"\n            onDoubleClick={addRoom}\n            onClick={() => setSelectedRoom(null)}\n            onKeyDown={keyHandler}\n        />\n    );\n}\n","import { Path, Points } from \"./interfaces\";\nimport { Room } from './interfaces'\nimport Point from \"./components/Point\";\n\nexport function getPolygon(points) {\n    return points.map((point) => [point.x, point.y].join(\" \"));\n}\n\nexport function getPath(points) {\n    return points.reduce((acc, current, i) => {\n        acc[i] = [\n            current];\n        if (i > 0) {\n            acc[i - 1].push(current)\n        }\n        if (i === points.length - 1) acc[i].push(acc[0][0]);\n        return acc;\n    }, []);\n}\n\nexport function getAllPoints(rooms) {\n    let array = rooms.reduce((acc, curr, i) => {\n        const roomPoints = curr.getPoints()\n        acc.push(...roomPoints)\n        return acc\n    }, [])\n    return array\n}\n\nexport const getPointCoords = (clickCoords, pathPoints) => {   // y = m*x + p \n    const [a, b] = pathPoints\n    let [x, y] = clickCoords\n\n    console.log('x', x)\n    console.log('y', y)\n\n    const m = (b.y - a.y) / (b.x - a.x)\n    console.log('m',m)\n    const p = a.y - m*a.x\n\n    if (m === 0) {\n        y = a.y\n    } \n    else if (!isFinite(m)) {\n        x = a.x\n    } else \n        y = m*x + p\n\n    return { x, y }\n\n}\n\n","import React from \"react\";\n\nexport default function Floor({polygon}) {\n    return <polygon points={polygon} fill=\"#ffffaa\" stroke=\"steelblue\" />;\n}\n///add memo\n","import React, { useContext } from \"react\";\nimport { RoomContext } from './../RoomContext'\nimport { DraggableCore, DraggableData } from \"react-draggable\";\nimport { Points, XY } from \"../interfaces\";\nimport {  getAllPoints } from \"../utils\";\n\nfunction Point({\n    point,\n    visible,\n}: {\n    point: any;\n    visible: boolean;\n}) {\n\n    const { __rooms } = useContext(RoomContext)\n    const [rooms, setRooms] = __rooms\n    \n    const roomIndex = rooms.findIndex(room => room.id === point.room)\n\n    if (!visible) {\n        return null;\n    }\n\n    const dragging = (e: any, dnd: DraggableData) => {\n\n        rooms[roomIndex].points[point.i].x = point.x + dnd.deltaX\n        rooms[roomIndex].points[point.i].y = point.y + dnd.deltaY\n\n        setRooms([...rooms])\n    };\n\n    const dragEnd = () => {\n\n        let allPoints = getAllPoints(rooms)\n\n        console.log(allPoints)\n\n        allPoints.map(otherPoint => {\n            console.log(otherPoint.i)\n            console.log(otherPoint.room)\n            if (otherPoint.room !== point.room || otherPoint.i !== point.i) {\n                if (Math.abs(point.absX - otherPoint.absX) < 16) {\n                    rooms[roomIndex].points[point.i].x = otherPoint.absX - point.offsetX\n                }\n                if (Math.abs(point.absY - otherPoint.absY) < 16) {\n                    rooms[roomIndex].points[point.i].y = otherPoint.absY - point.offsetY\n                }\n                \n            }\n        })\n        setRooms([...rooms])\n    };\n\n    return (\n        <DraggableCore\n            handle=\".corner\"\n            onDrag={dragging}\n            onStop={dragEnd}\n        >\n            <g>\n                <circle\n                    className=\"corner\"\n                    cx={point.x}\n                    cy={point.y}\n                    r={16}\n                    fill={\"white\"}\n                    stroke={\"#38a0f9\"}\n                    strokeWidth={4}\n                />\n                <text\n                    x={point.x}\n                    y={point.y}\n                    textAnchor=\"middle\"\n                    alignmentBaseline=\"central\"\n                    pointerEvents=\"none\"\n                    fill=\"grey\"\n                >\n                    {point.i}\n                </text>\n            </g>\n        </DraggableCore>\n    );\n}\n\nexport default Point;\n","import React, { useState, useContext } from \"react\";\nimport { line } from \"d3-shape\";\nimport { DraggableCore } from \"react-draggable\";\nimport { Points } from './../interfaces'\nimport { RoomContext } from './../RoomContext'\nimport Point from \"./Point\";\nimport { getAllPoints } from \"../utils\";\n\nexport default function Segment({\n    pathPoints,\n    visible,\n    segmentIndex,\n}: {\n    pathPoints: any,\n    visible: boolean,\n    segmentIndex: number\n}) {\n\n    const { __quickMenuPosition, __quickMenuState, __selectedPathPoints, __rooms, __pointer, __pathNode } = useContext(RoomContext)\n\n    const [quickMenuPosition, setQuickMenuPosition] = __quickMenuPosition\n    const [quickMenuState, setQuickMenuState] = __quickMenuState\n    const [selectedPathPoints, setSelectedPathPoints] = __selectedPathPoints\n    const [rooms, setRooms] = __rooms\n    const [pointer, setPointer] = __pointer\n    const [pathNode, setPathNode] = __pathNode\n\n    const [isDragging, setIsDragging] = useState(false)\n\n    let [a, b] = pathPoints;\n\n    const roomIndex = rooms.findIndex(room => room.id === a.room)\n\n    let data = [[a.x, a.y], [b.x, b.y]]\n\n    let path = line()\n        .x((d) => d[0])\n        .y((d) => d[1])\n\n    const dragging = (e, dnd) => {\n\n        setIsDragging(true)\n\n        a.x += dnd.deltaX\n        a.y += dnd.deltaY\n\n        b.x += dnd.deltaX\n        b.y += dnd.deltaY\n\n        rooms[roomIndex].points[a.i].x = a.x\n        rooms[roomIndex].points[a.i].y = a.y\n\n        rooms[roomIndex].points[b.i].x = b.x\n        rooms[roomIndex].points[b.i].y = b.y\n\n        setRooms([...rooms])\n    }\n\n    const dragEnd = (e, dnd) => {\n\n        if (!isDragging) {\n            segmentClicked(e)\n            return\n        }\n        setIsDragging(false)\n\n        let allPoints = getAllPoints(rooms)\n\n        pathPoints.forEach(pathPoint => {\n            allPoints.forEach(point => {\n                if (pathPoint.id !== point.id) {\n                    if (Math.abs(pathPoint.absX - point.absX) <= 16) {\n                        rooms[roomIndex].points[pathPoint.i].x = point.absX - pathPoint.offsetX\n                    }\n                    if (Math.abs(pathPoint.absY - point.absY) <= 16) {\n                        rooms[roomIndex].points[pathPoint.i].y = point.absY - pathPoint.offsetY\n                    }\n                }\n            });\n        });\n        setRooms([...rooms])\n    }\n\n    const segmentClicked = e => {\n        setPointer({x : e.clientX, y : e.clientY})\n        e.preventDefault()\n\n        let x\n        let y\n\n        if (e.type === 'mouseup') {\n            x = e.clientX\n            y = e.clientY\n        } else {\n            x = e.touches[0].pageX\n            y = e.touches[0].pageY\n        }\n\n\n        setQuickMenuPosition({ x, y })\n        setQuickMenuState(prev => !prev)\n        setSelectedPathPoints(pathPoints)\n        setPathNode(e.target)\n    }\n\n    // if (!visible) {\n    //     return null;\n    // }\n\n    return (\n        <DraggableCore\n            handle=\".segment\"\n            //onStart={() => setIsDragging(true)}\n            onDrag={dragging}\n            onStop={dragEnd}\n        >\n            <path\n                style={ visible ?  { visibility : \"visible\" } : { visibility : 'hidden'}}\n                d={path(data)}\n                id={a.room + '.' + a.i + '.' + b.i}\n                className=\"segment\"\n                strokeWidth={20}\n                stroke=\"#77cfff\"\n                opacity={0.8}\n            //onClick={e => segmentClicked(e)}\n            />\n        </DraggableCore>\n    );\n}\n","import React from \"react\";\n\nfunction Size({pathPoints, visible}) {\n    const [a, b] = pathPoints;\n\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n\n    var c = Math.round(Math.floor(Math.sqrt(dx * dx + dy * dy)/5)*5)\n\n    if (!visible) {\n        return null;\n    }\n\n    return (\n        <text style={{pointerEvents:'none', fill:'#404040'}}>\n            <textPath startOffset=\"45%\" xlinkHref={\"#\" + a.i + '.' + b.i}>\n                {c}\n            </textPath>\n        </text>\n    );\n}\n\nexport default Size;\n","import React, { useContext } from 'react'\nimport { getPointCoords } from '../utils'\nimport { RoomContext } from \"../RoomContext\";\n\nexport default function Door({door}) {\n\n    const { __rooms } = useContext(RoomContext)\n\n    const [rooms] = __rooms\n\n\n    const { pointsIds, XFromOrigin } = door\n    console.log(pointsIds.a)\n    const roomId = pointsIds.a.split('.')[0]\n    console.log(roomId)\n    const roomIndex = rooms.findIndex(room => room.id === roomId)\n    const aIndex = rooms[roomIndex].getPoints().findIndex(point => point.id === pointsIds.a)\n    const bIndex = rooms[roomIndex].getPoints().findIndex(point => point.id === pointsIds.b)\n\n    const a = rooms[roomIndex].points[aIndex]\n    const b = rooms[roomIndex].points[bIndex]\n\n    console.log(a)\n    console.log(b)\n\n    //console.log(pointsIds)\n    //console.log(XFromOrigin)\n\n    //const rel = el instanceof SVGPathElement ? el.getPointAtLength(door.XFromOrigin) : {x : 10, y : 10}\n    //const point = { x : rel.x , y : rel.y }\n\n    //console.log(point)\n    \n    return (\n\n\n        <circle\n            cx={(a.x + b.x)/2}\n            cy={(a.y + b.y)/2}\n            r={10}\n            fill='pink'\n        />\n    )\n}\n","import React, { useState, useEffect, useContext } from \"react\";\nimport { RoomContext } from './../RoomContext'\nimport { DraggableCore, DraggableData } from \"react-draggable\";\nimport { getPath, getPolygon, getAllPoints } from \"./../utils\";\nimport Floor from \"./Floor\";\nimport Point from \"./Point\";\nimport Segment from \"./Segment\";\nimport Size from \"./Size\";\nimport Door from './Door'\n\nfunction Room({\n    isSelected,\n    room,\n    i\n}: {\n    isSelected: boolean;\n    room: any;\n    i: number\n}) {\n\n    const { __rooms, __selectedRoom } = useContext(RoomContext)\n    const [rooms, setRooms] = __rooms\n    const [selectedRoom, setSelectedRoom] = __selectedRoom\n\n    const deleteRoom = (e: any) => {\n        if (isSelected) {\n            if (e.keyCode === 8) {\n                setRooms((rooms: any) => rooms.filter((el: any) => el.id !== room.id));\n            }\n        }\n    };\n\n    const dragging = (e: any, dnd: DraggableData) => {\n        e.preventDefault()\n\n        const newRooms = [...rooms]\n        newRooms[i].x += dnd.deltaX\n        newRooms[i].y += dnd.deltaY\n\n        setRooms(newRooms)\n    };\n\n    const dragEnded = (e, dnd) => {\n\n        const allPoints = getAllPoints(rooms)\n\n        room.getPoints().forEach(point => {\n            allPoints.forEach(otherPoint => {\n\n                let dx = Math.abs(point.absX - otherPoint.absX)\n                let dy = Math.abs(point.absY - otherPoint.absY)\n\n                if (point.room !== otherPoint.room) {\n                    if (dx <= 16) {\n                        rooms[i].points[point.i].x = otherPoint.absX - point.offsetX\n                    }\n                    if (dy <= 16) {\n                        rooms[i].points[point.i].y = otherPoint.absY - point.offsetY\n                    }\n                }\n            })\n        })\n        setRooms([...rooms])\n    }\n\n    return (\n        <DraggableCore\n            handle=\".room\"\n            cancel=\".corner, .segment\"\n            disabled={!isSelected}\n            onStop={dragEnded}\n            onDrag={dragging}\n        >\n            <g\n                className={\"room\"}\n                id={room.id}\n                transform={`translate(${room.x} ${room.y})`}\n                onClick={() => {\n                    setSelectedRoom(room.id);\n                }}\n                onKeyDown={deleteRoom}\n                tabIndex={-1}\n                style={{ outline: 0 }}\n            >\n                <Floor\n                    polygon={getPolygon(room.getPoints())}\n                />\n\n                {getPath(room.getPoints()).map((pathPoints, index) => (\n                    <Segment\n                        key={index}\n                        pathPoints={pathPoints}\n                        visible={isSelected}\n                        segmentIndex={index}\n                    />\n                ))}\n\n                {room.getPoints().map((point, index) => (\n                    <Point\n                        key={index}\n                        point={point}\n                        visible={isSelected}\n                    />\n                ))}\n                {getPath(room.getPoints()).map((pathPoints, index) => (\n                    <Size\n                        key={index}\n                        pathPoints={pathPoints}\n                        visible={isSelected}\n                    />\n                ))}\n                {room.doors.map((door, i) => (\n                    <Door \n                        key={i}\n                        door={door}\n                    />\n                ))}\n            </g>\n        </DraggableCore>\n    );\n}\n\nexport default Room;\n\n","import React, { useState, useContext } from \"react\";\nimport Background from \"./Background\";\nimport Room from \"./Room\";\nimport { RoomContext } from \"../RoomContext\";\n\nexport default function Plan() {\n\n    const { __rooms, __selectedRoom, __doors } = useContext(RoomContext)\n\n    const [rooms] = __rooms;\n    const [selectedRoom] = __selectedRoom;\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const [doors] = __doors;\n\n    return (\n        <svg width={width} height={height}>\n            <Background\n                width={width}\n                height={height}\n            />\n\n            {\n                rooms\n                    .sort((a, b) => {\n                        const c = (a.id === selectedRoom)\n                        const d = (b.id === selectedRoom)\n                        return (c === d) ? 0 : c ? 1 : - 1\n                    })\n                    .map((room, i) => {\n                        return (\n                            <Room\n                                key={room.id}\n                                isSelected={selectedRoom === room.id ? true : false}\n                                room={room}\n                                i={i}\n                            />\n                        );\n                    })\n            }\n\n\n\n\n        </svg>\n    );\n}\n","import React, { useContext } from 'react'\nimport { Menu, MenuItem } from '@material-ui/core'\nimport { getPointCoords, getPath, getAllPoints } from './../../utils'\nimport { RoomContext } from './../../RoomContext'\n\nconst QuickMenu = () => {\n\n    const {\n        __quickMenuPosition,\n        __quickMenuState,\n        __selectedPathPoints,\n        __rooms,\n        __selectedRoom,\n        __pointer,\n        __doors,\n        __pathNode\n    } = useContext(RoomContext)\n\n    const [quickMenuPosition, setQuickMenuPosition] = __quickMenuPosition\n    const [quickMenuState, setQuickMenuState] = __quickMenuState\n    const [selectedPathPoints, setSelectedPathPoints] = __selectedPathPoints\n    const [rooms, setRooms] = __rooms\n    const [selectedRoom, setSelectedRoom] = __selectedRoom\n    const [pointer] = __pointer\n    const [doors, setDoors] = __doors\n    const [pathNode] = __pathNode\n    \n    //console.log(pointer)\n    \n    const handleClose = (e) => {\n        setQuickMenuState(false)\n        setQuickMenuPosition(null)\n    }\n    \n    const addCorner = e => {\n        e.persist()\n        console.log(e)\n        \n        const [a, b] = selectedPathPoints\n        const roomIndex = rooms.findIndex(room => room.id === a.room)\n        \n        const x = pointer.x - rooms[roomIndex].x\n        const y = pointer.y - rooms[roomIndex].y\n        \n        const newPoint = getPointCoords([x, y], selectedPathPoints)\n        \n        console.log(newPoint)\n        \n        getAllPoints(rooms).forEach(point => {\n            console.log(newPoint)\n            if (Math.abs(point.absX - (newPoint.x + rooms[roomIndex].x)) < 16) {\n                newPoint.x = point.absX - rooms[roomIndex].x\n            }\n            if (Math.abs(point.absY - (newPoint.y + rooms[roomIndex].y)) < 16) {\n                newPoint.y = point.absY - rooms[roomIndex].y\n            }\n        })\n        \n        const point1 = { ...newPoint }\n        const point2 = { ...newPoint }\n        \n        rooms[roomIndex].points.splice(a.i + 1, 0, point1, point2)\n        setRooms([...rooms])\n        \n        handleClose(e)\n    }\n    \n    const addDoor = e => {\n        \n        const [a, b] = selectedPathPoints\n        \n        const roomIndex = rooms.findIndex(room => room.id === a.room)\n\n        const XFromOrigin = pointer.x - rooms[roomIndex].x\n\n        const pointsIds = { a: a.id, b: b.id }\n\n        const door = { pointsIds, XFromOrigin }\n\n        rooms[roomIndex].doors.push(door)\n        \n        setRooms([...rooms])\n        \n        handleClose(e)\n\n    }\n\n\n    return (\n        <Menu\n            id=\"quickMenu\"\n            transitionDuration={{ enter: 0, exit: 0 }}\n            anchorReference=\"anchorPosition\"\n            anchorPosition={\n                quickMenuPosition !== null\n                    ? { top: quickMenuPosition.y, left: quickMenuPosition.x }\n                    : undefined\n            }\n            open={quickMenuState}\n            onClose={handleClose}\n        >\n            <MenuItem\n                onClick={addCorner}>\n                new corner\n            </MenuItem>\n\n            <MenuItem onClick={addDoor}>new door</MenuItem>\n        </Menu>\n    )\n}\n\nexport default QuickMenu\n","import React, { useState } from \"react\";\nimport Plan from \"./components/Plan\";\nimport \"./App.css\";\nimport QuickMenu from './components/UI/QuickMenu'\nimport { RoomContext } from './RoomContext'\n\nfunction App() {\n\n    const __quickMenuPosition = useState(null)\n    const __quickMenuState = useState(false)\n    const __rooms = useState([])\n    const __selectedRoom = useState(null)\n    const __selectedPathPoints = useState(null)\n    const __pointer = useState(null)\n    const __doors = useState([])\n    const __pathNode = useState(null)\n\n    const CTX = {\n        __quickMenuPosition,\n        __quickMenuState,\n        __selectedRoom,\n        __rooms,\n        __selectedPathPoints,\n        __pointer,\n        __doors,\n        __pathNode\n    }\n    \n\n    return (\n        <div\n            className=\"App\"\n            style={{ overscrollBehavior: \"none\" }}\n            onContextMenu={e => e.preventDefault()}\n        >\n            <RoomContext.Provider value={CTX}>\n                <Plan/>\n                <QuickMenu/>\n            </RoomContext.Provider>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === \"localhost\" ||\n        // [::1] is the IPv6 localhost address.\n        window.location.hostname === \"[::1]\" ||\n        // 127.0.0.1/8 is considered localhost for IPv4.\n        window.location.hostname.match(\n            /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n        ),\n);\n\ninterface Config {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n}\n\nexport function register(config?: Config) {\n    if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(\n            (process as {env: {[key: string]: string}}).env.PUBLIC_URL,\n            window.location.href,\n        );\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener(\"load\", () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        \"This web app is being served cache-first by a service \" +\n                            \"worker. To learn more, visit http://bit.ly/CRA-PWA\",\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then((registration) => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === \"installed\") {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                \"New content is available and will be used when all \" +\n                                    \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\",\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log(\"Content is cached for offline use.\");\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch((error) => {\n            console.error(\"Error during service worker registration:\", error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then((response) => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get(\"content-type\");\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf(\"javascript\") === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then((registration) => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\n                \"No internet connection found. App is running in offline mode.\",\n            );\n        });\n}\n\nexport function unregister() {\n    if (\"serviceWorker\" in navigator) {\n        navigator.serviceWorker.ready.then((registration) => {\n            registration.unregister();\n        });\n    }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}