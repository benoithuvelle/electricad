{"version":3,"sources":["components/Background.tsx","utils.ts","components/Floor.tsx","components/Point.tsx","components/Segment.tsx","components/Size.tsx","components/Room.tsx","components/Plan.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Background","setSelectedRoom","setRooms","rooms","width","height","id","fill","onDoubleClick","e","window","prompt","find","room","alert","coords","clientX","clientY","points","onClick","getPolygon","map","point","join","getPath","reduce","acc","current","i","XY","push","length","getPointsAbsolutePosition","dx","dy","getAllPointsAbsolutePosition","curr","roomPoints","Floor","polygon","stroke","Point","pointIndex","setPoints","visible","x","y","handle","onDrag","dnd","newPoints","deltaX","deltaY","onStop","otherPoint","Math","abs","console","log","className","cx","cy","r","strokeWidth","textAnchor","alignmentBaseline","pointerEvents","Segment","pathPoints","segmentIndex","a","b","data","ax","ay","bx","by","path","line","d","newPathPoints","allPoints","el","opacity","persist","box","target","getBoundingClientRect","pointer","newPoint","left","m","p","Infinity","top","index1","splice","Size","c","round","floor","sqrt","startOffset","xlinkHref","Room","isSelected","roomIndex","defaultPoints","useState","useEffect","updateRoom","index","slice","cancel","disabled","allOtherPoints","filter","_","getAllPointsButThisRoom","pointA","pointB","roomUpdate","preventDefault","transform","onKeyDown","keyCode","tabIndex","style","outline","key","Plan","selectedRoom","innerWidth","innerHeight","sort","App","overscrollBehavior","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b75791dc.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default function Background({\n    setSelectedRoom,\n    setRooms,\n    rooms,\n    width,\n    height,\n}: {\n    setSelectedRoom: any;\n    setRooms: any;\n    rooms: any;\n    width: number;\n    height: number;\n}) {\n    const addRoom = (e: any) => {\n        const id = window.prompt(\"Dénomination de la pièce\");\n\n        if (rooms.find((room) => room.id === id)) {\n            alert(`Une pièce nommée ${id} existe déjà. Création annulée !!!`);\n            return;\n        }\n        const room = {\n            id: id,\n            coords: [e.clientX - 75, e.clientY - 75],\n            points: [[0, 0], [0, 150], [150, 150], [150, 0]]\n        };\n        \n        setRooms([...rooms, room]);\n        setSelectedRoom(room.id);\n    };\n\n    return (\n        <rect\n            id=\"background\"\n            width={width}\n            height={height}\n            fill=\"#38a0f9\"\n            onDoubleClick={addRoom}\n            onClick={() => setSelectedRoom(null)}\n        />\n    );\n}\n","import { Path, Points } from \"./interfaces\";\nimport { Room } from './interfaces'\n\nexport function getPolygon(points: Points) {\n    return points.map((point) => [point[0], point[1]].join(\" \"));\n}\n\nexport function getPath(points: Points) {\n    return points.reduce((acc, current, i) => {\n        acc[i] = [{ XY: current, i: i }];\n        if (i > 0) {\n\n            acc[i - 1].push({ XY: current, i: i })\n        }\n        if (i === points.length - 1) acc[i].push(acc[0][0]);\n        return acc;\n    }, []);\n}\n\n\nexport function getAllPointsButThisRoom(rooms, roomIndex) {\n    let array = rooms\n        .filter((_, i) => i !== roomIndex)\n        .reduce((acc, curr, i) => {\n            curr.points.map(point => {\n                point.dx = curr.coords[0]\n                point.dy = curr.coords[1]\n                acc.push(point)\n            })\n            return acc\n        }, [])\n    return array\n}\n\nexport function getPointsAbsolutePosition(room) {\n    let array = room.points\n        .map(point => {\n            //console.log(point)\n            point.dx = room.coords[0]\n            point.dy = room.coords[1]\n            return point\n        })\n    return array\n}\n\nexport function getAllPointsAbsolutePosition(rooms) {\n    let array = rooms.reduce((acc, curr, i) => {\n        const roomPoints = getPointsAbsolutePosition(curr)\n        acc.push(...roomPoints)\n        return acc\n    }, [])\n    return array\n}\n\nexport function getThisRoomPoints(room : Room): Points {\n    let array = room.points.reduce((acc, curr, i) => {\n        acc[i] = {\n            x : curr[0],\n            y : curr[1],\n            dx : curr[0] + room.coords[0],\n            dy : curr[1] + room.coords[1],\n            i : i\n        }\n    }, [])\n    return array\n}\n","import React from \"react\";\n\nexport default function Floor({polygon}) {\n    return <polygon points={polygon} fill=\"#ffffaa\" stroke=\"steelblue\" />;\n}\n///add memo\n","import React from \"react\";\nimport { DraggableCore, DraggableData } from \"react-draggable\";\nimport { Points, XY } from \"../interfaces\";\nimport { getPointsAbsolutePosition, getAllPointsAbsolutePosition } from \"../utils\";\n\nfunction Point({\n    coords,\n    point,\n    pointIndex,\n    points,\n    setPoints,\n    visible,\n    rooms,\n}: {\n    coords: any;\n    point: any;\n    pointIndex: number;\n    points: any;\n    setPoints: any;\n    visible: boolean;\n    rooms: any;\n}) {\n    if (!visible) {\n        return null;\n    }\n\n    const x = point[0];\n    const y = point[1];\n\n    const dragging = (e: any, dnd: DraggableData) => {\n        const newPoints = [...points];\n        newPoints[pointIndex] = [x + dnd.deltaX, y + dnd.deltaY];\n        setPoints(newPoints);\n    };\n\n    const dragEnd = () => {\n\n        let newPoints = [ ... points ]\n\n        let allPoints = getAllPointsAbsolutePosition(rooms)\n\n        allPoints.map(otherPoint => {\n            if (otherPoint !== point) {\n                if (Math.abs((point[0] + coords[0]) - (otherPoint[0] + otherPoint.dx)) < 10) {\n                    newPoints[pointIndex][0] = otherPoint[0] + otherPoint.dx - coords[0]\n                }\n                if (Math.abs((point[1] + coords[1]) - (otherPoint[1] + otherPoint.dy)) < 10) {\n                    console.log('match')\n                    newPoints[pointIndex][1] = otherPoint[1] + otherPoint.dy - coords[1]\n                }\n            }\n        })\n        setPoints(newPoints)\n    };\n\n    return (\n        <DraggableCore\n            handle=\".corner\"\n            onDrag={dragging}\n            onStop={dragEnd}\n        >\n            <g>\n                <circle\n                    className=\"corner\"\n                    cx={x}\n                    cy={y}\n                    r={16}\n                    fill={\"white\"}\n                    stroke={\"#38a0f9\"}\n                    strokeWidth={4}\n                />\n                <text\n                    x={x}\n                    y={y}\n                    textAnchor=\"middle\"\n                    alignmentBaseline=\"central\"\n                    pointerEvents=\"none\"\n                    fill=\"grey\"\n                >\n                    {2}\n                </text>\n            </g>\n        </DraggableCore>\n    );\n}\n\nexport default Point;\n","import { line } from \"d3-shape\";\nimport React from \"react\";\nimport { DraggableCore } from \"react-draggable\";\nimport { Points } from './../interfaces'\nimport { getAllPointsAbsolutePosition } from \"../utils\";\n\nexport default function Segment({\n    pathPoints,\n    visible,\n    segmentIndex,\n    setPoints,\n    points,\n    rooms\n}: {\n    pathPoints: any,\n    visible: boolean,\n    segmentIndex: number\n    setPoints: any,\n    points: any,\n    rooms: any\n}) {\n\n    console.log(pathPoints)\n    let [a, b] = pathPoints;\n\n    let data = [a.XY, b.XY]\n\n    //console.log(a)\n\n    let [ax, ay] = a.XY;\n    let [bx, by] = b.XY;\n\n    ////console.log(ax)\n\n    let path = line()\n        .x((d) => d[0])\n        .y((d) => d[1])\n\n    const dragging = (e, dnd) => {\n\n        const newPathPoints = [...pathPoints]\n        newPathPoints[0] = [ax + dnd.deltaX, ay + dnd.deltaY]\n        newPathPoints[1] = [bx + dnd.deltaX, by + dnd.deltaY]\n\n        const newPoints = [...points]\n\n        newPoints[a.i] = newPathPoints[0]\n        newPoints[b.i] = newPathPoints[1]\n\n        setPoints([...newPoints])\n    }\n\n    const dragEnd = (e, dnd) => {\n\n        let allPoints = getAllPointsAbsolutePosition(rooms)\n\n        let newPoints = [ ... points]\n        console.log(newPoints)\n\n        allPoints.map(el => {\n\n                if (Math.abs((el[0] + el.dx) - (ax + a.XY.dx)) <= 16) {\n                    newPoints[a.i][0] = el.dx + el[0] - a.XY.dx\n                    console.log('match')\n                }\n                if (Math.abs((el[1] + el.dy) - (ay + a.XY.dy)) <= 16) {\n                    newPoints[a.i][1] = el.dy + el[1] - a.XY.dy\n                    console.log('match')\n\n                }\n                if (Math.abs((el[0] + el.dx) - (bx + b.XY.dx)) <= 16) {\n                    newPoints[b.i][0] = el.dx + el[0] - b.XY.dx\n                    console.log('match')\n\n                }\n                if (Math.abs((el[1] + el.dy) - (by + b.XY.dy)) <= 16) {\n                    newPoints[b.i][1] = el.dy + el[1] - b.XY.dy\n                    console.log('match')\n\n                }\n                setPoints([...newPoints])\n        })\n    }\n\n    const addPoint = (e) => {\n        \n        e.persist()\n        ////////console.log(e.target.getBoundingClientRect())\n        ////////console.log(e.clientX)\n        //////console.log(e.target)\n\n        let box = e.target.getBoundingClientRect()\n        //////console.log(box.left)\n        //////console.log(e.clientX)\n        let pointer = [e.clientX, e.clientY]\n\n        let newPoint = []\n\n        newPoint[0] = pathPoints[0].XY[0] < pathPoints[1].XY[0] ? pointer[0] - box.left + pathPoints[0].XY[0] : pointer[0] - box.left + pathPoints[1].XY[0]\n        // y = mx + b\n\n        let a = pathPoints[0]\n        let b = pathPoints[1]\n\n        ////console.log(a.id.split('.')[2],b.id.split('.')[2])\n\n        let dx = a.XY[0] - b.XY[0]\n        let dy = a.XY[1] - b.XY[1]\n\n        let m = dy / dx\n        let p = a.XY[1] - m * a.XY[0]\n\n        ////////console.log(m)\n\n        if (m === 0) {\n            ////////console.log('ligne horizontale')\n            newPoint[1] = a.XY[1]\n        }\n\n        else if (m === Infinity || m === -Infinity) {\n            ////////console.log('ligne verticale')\n            newPoint[0] = a.XY[0]\n            newPoint[1] = a.XY[1] < b.XY[1] ? Math.abs(pointer[1] - box.top + a.XY[1]) : Math.abs(pointer[1] - box.top + b.XY[1])\n        }\n\n        else {\n            newPoint[1] = m * newPoint[0] + p //+ (a.XY[0])\n            //point.y = m * point.x + p\n        }\n\n        //point.id = room.id + '.corner.' + room.points.length + 1\n\n        let index1 = a.i\n        let index2 = b.i\n\n        points.splice(index1 + 1, 0, newPoint)\n\n        setPoints([...points])\n        console.log(points)\n    }\n\n    if (!visible) {\n        return null;\n    }\n\n    return (\n        <DraggableCore\n            handle=\".segment\"\n            //onStart={dragStarted}\n            onDrag={dragging}\n            onStop={dragEnd}\n        >\n            <path\n                d={path(data)}\n                id={a.i + '.' + b.i}\n                className=\"segment\"\n                strokeWidth={20}\n                stroke=\"#77cfff\"\n                opacity={0.8}\n                onDoubleClick={addPoint}\n            />\n        </DraggableCore>\n    );\n}\n","import React from \"react\";\n\nfunction Size({pathPoints, visible}) {\n    const [a, b] = pathPoints;\n    const [ax, ay] = a.XY;\n    const [bx, by] = b.XY;\n\n    var dx = ax - bx;\n    var dy = ay - by;\n\n    var c = Math.round(Math.floor(Math.sqrt(dx * dx + dy * dy)/5)*5)\n\n    if (!visible) {\n        return null;\n    }\n\n    return (\n        <text>\n            <textPath startOffset=\"45%\" xlinkHref={\"#\" + a.i + '.' + b.i}>\n                {c}\n            </textPath>\n        </text>\n    );\n}\n\nexport default Size;\n","import React, { useState, useEffect } from \"react\";\nimport { DraggableCore, DraggableData } from \"react-draggable\";\nimport { Points } from \"../interfaces\";\nimport { getPath, getPolygon, getAllPointsButThisRoom, getPointsAbsolutePosition } from \"./../utils\";\nimport Floor from \"./Floor\";\nimport Point from \"./Point\";\nimport Segment from \"./Segment\";\nimport Size from \"./Size\";\n\nfunction Room({\n    setRooms,\n    setSelectedRoom,\n    isSelected,\n    roomIndex,\n    id,\n    coords,\n    room,\n    rooms,\n    points:defaultPoints\n}: {\n    setRooms: any;\n    setSelectedRoom: any;\n    isSelected: boolean;\n    roomIndex: number;\n    id: string;\n    coords: any;\n    room: any;\n    rooms: any;\n    points: Points\n}) {\n\n    const [points, setPoints] = useState<Points>(defaultPoints);\n\n    useEffect(() => {\n        updateRoom(room, roomIndex)\n    }, [points])\n\n    \n\n    const deleteRoom = (e: any) => {\n        if (isSelected) {\n            if (e.keyCode === 8) {\n                setRooms((rooms: any) => rooms.filter((el: any) => el.id !== id));\n            }\n        }\n    };\n\n    const updateRoom = (room: any, index: number) => {\n        ////console.log(' room updating')\n        setRooms((rooms: any) => [\n            ...rooms.slice(0, index),\n            { ...room, points : points },\n            ...rooms.slice(index + 1),\n        ]);\n    };\n\n    const dragging = (e: any, dnd: DraggableData) => {\n        e.preventDefault()\n\n        coords[0] += dnd.deltaX\n        coords[1] += dnd.deltaY\n\n        updateRoom(room, roomIndex)\n    };\n\n    const dragEnded = (e, dnd) => {\n\n        const roomPoints = getPointsAbsolutePosition(room)\n\n        const allOtherPoints = getAllPointsButThisRoom(rooms, roomIndex)\n        let newPoints = roomPoints.map(pointA => {\n            allOtherPoints.map(pointB => {\n                \n                let a = pointA[0] + pointA.dx\n                let b = pointB[0] + pointB.dx\n                let dx = Math.abs(a - b)\n                if (dx <= 10) {\n                    pointA[0] = b - pointA.dx\n                }\n            })\n            allOtherPoints.map(pointB => {\n                let a = pointA[1] + pointA.dy\n                let b = pointB[1] + pointB.dy\n                let dy = Math.abs(a - b)\n                if (dy <= 10) {\n                    pointA[1] = b - pointA.dy\n                }\n            })\n            return pointA\n        })\n\n        const roomUpdate = { ...room, points: newPoints}\n        updateRoom(roomUpdate, roomIndex)\n    }\n\n    return (\n        <DraggableCore\n            handle=\".room\"\n            cancel=\".corner, .segment\"\n            disabled={!isSelected}\n            onStop={dragEnded}\n            onDrag={dragging}\n        >\n            <g\n                className={\"room\"}\n                id={id}\n                transform={`translate(${coords[0]} ${coords[1]})`}\n                onClick={() => {\n                    setSelectedRoom(id);\n                }}\n                onKeyDown={deleteRoom}\n                tabIndex={-1}\n                style={{ outline: 0 }}\n            >\n                <Floor\n                    polygon={getPolygon(points)}\n                />\n\n                {getPath(points).map((pathPoints, index) => (\n                    <Segment\n                        key={index}\n                        pathPoints={pathPoints}\n                        visible={isSelected}\n                        segmentIndex={index}\n                        setPoints={setPoints}\n                        points={points}\n                        rooms={rooms}\n                    />\n                ))}\n\n                {points.map((point, index) => (\n                    <Point\n                        coords={coords}\n                        key={index}\n                        point={point}\n                        pointIndex={index}\n                        points={points}\n                        setPoints={setPoints}\n                        visible={isSelected}\n                        rooms={rooms}\n                    />\n                ))}\n                {getPath(points).map((pathPoints, index) => (\n                    <Size\n                        key={index}\n                        pathPoints={pathPoints}\n                        visible={isSelected}\n                    />\n                ))}\n            </g>\n        </DraggableCore>\n    );\n}\n\nexport default Room;\n// export default React.memo(Room,\n//     (prevProps, nextProps) => {\n//         if (prevProps.room === nextProps.room && prevProps.isSelected === nextProps.isSelected) {\n//             return true;\n//         }\n//         return false;\n//     })\n","import React, {useState} from \"react\";\nimport Background from \"./Background\";\nimport Room from \"./Room\";\n\nexport default function Plan() {\n    const [rooms, setRooms] = useState([]);\n    const [selectedRoom, setSelectedRoom] = useState(null);\n\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    // Array.from(document.getElementsByTagName(\"circle\")).map((e) => { return e.getBoundingClientRect()  })\n\n    return (\n        <svg width={width} height={height}>\n            <Background\n                width={width}\n                height={height}\n                setSelectedRoom={setSelectedRoom}\n                setRooms={setRooms}\n                rooms={rooms}\n            />\n\n            \n\n            {rooms\n            .sort((a,b) => {\n                const c = (a.id === selectedRoom)\n                const d = (b.id === selectedRoom)\n                return (c === d) ? 0 : c ? 1 : - 1\n            })\n            .map((room, i) => {\n                return (\n                    <Room\n                        key={room.id}\n                        roomIndex={i}\n                        id={room.id}\n                        coords={room.coords}\n                        isSelected={selectedRoom === room.id ? true : false}\n                        setSelectedRoom={setSelectedRoom}\n                        rooms={rooms}\n                        setRooms={setRooms}\n                        room={room}\n                        points={room.points}\n                    />\n                );\n            })}\n        </svg>\n    );\n}\n","import React from \"react\";\nimport Plan from \"./components/Plan\";\nimport \"./App.css\";\n\nfunction App() {\n    console.log(\"app rendering\");\n\n    return (\n        <div className=\"App\" style={{overscrollBehavior: \"none\"}}>\n            <Plan />\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === \"localhost\" ||\n        // [::1] is the IPv6 localhost address.\n        window.location.hostname === \"[::1]\" ||\n        // 127.0.0.1/8 is considered localhost for IPv4.\n        window.location.hostname.match(\n            /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n        ),\n);\n\ninterface Config {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n}\n\nexport function register(config?: Config) {\n    if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(\n            (process as {env: {[key: string]: string}}).env.PUBLIC_URL,\n            window.location.href,\n        );\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener(\"load\", () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        \"This web app is being served cache-first by a service \" +\n                            \"worker. To learn more, visit http://bit.ly/CRA-PWA\",\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then((registration) => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === \"installed\") {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                \"New content is available and will be used when all \" +\n                                    \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\",\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log(\"Content is cached for offline use.\");\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch((error) => {\n            console.error(\"Error during service worker registration:\", error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then((response) => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get(\"content-type\");\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf(\"javascript\") === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then((registration) => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\n                \"No internet connection found. App is running in offline mode.\",\n            );\n        });\n}\n\nexport function unregister() {\n    if (\"serviceWorker\" in navigator) {\n        navigator.serviceWorker.ready.then((registration) => {\n            registration.unregister();\n        });\n    }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}